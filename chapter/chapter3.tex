\chapter{Algorithmen zum Zeichnen von Bäumen}
\label{chap:kapitel3}
Im Folgenden werden drei verschiedene Algorithmen zum Zeichnen von Bäumen im Ebenen-Layout vorgestellt. Wie in Kapitel \ref{chap:einleitung}
bereits angekündigt, wird jeweils auf den Ablauf, einer eigenen Implementierung in Java und auf die Vor- und Nachteile eingegangen. Ziel wird
es sein, Verständnis für diese Algorithmen zu schaffen.

\section{Naiver Algorithmus von Wetherell und Shannon}

Das Paper \glqq Tidy Drawings of Trees\grqq{} von Charles Wetherell und Alfred Shannon aus dem Jahre 1979, 
welches im IEEE Trans. Softw. Eng. erschienen ist, handelt von verschiedenen Algorithmen zum Zeichnen von Bäumen \cite[]{q1}.
Der erste Algorithmus, der von den beiden Autoren beschrieben und vorgestellt wird, ist ein naiver Algorithmus 
zum Zeichnen von Bäumen. Dieser Algorithmus soll dabei zwei Anforderungen erfüllen. Die erste Anforderung wird dabei
an die Ästhetik des gezeichneten Baumes gestellt. 
\begin{quotation}
	\textit{Aesthetic 1:} Nodes of a tree at the same height should lie
	along a straight line, and the straight lines defining the levels
<<<<<<< HEAD
	should be parallel \cite[S.515]{q1}.
=======
	should be parallel \cite[S. 515]{q1}.
>>>>>>> 47125e292bfcfdb0677f356a55bd4002e82bc2b5
\end{quotation}
Alle Knoten, die dieselbe Höhe haben, sollen sich auf einer horizontalen
Linie befinden. Jede Höhe hat dabei eine Linie, auf welcher sich die Knoten befinden sollen und diese Linien sollen alle
parallel zueinander sein. Außerdem soll der Algorithmus beim Zeichnen eines Baumes ein physikalisches Limit einhalten:
\begin{quotation}
	\textit{Physical limit:} Tree drawings should occupy as little width
	as possible (the height of a tree drawing is fixed by the tree
<<<<<<< HEAD
	itself) \cite[S.515]{q1}.
\end{quotation}
Das bedeutet, dass der Algorithmus möglichst schmale Bäume zeichnen soll. Jedoch wird die Höhe des Baumes durch diese Anforderungen
nicht eingeschränkt. Stattdessen ist die Höhe durch den Baum vorgegeben \cite[S.515]{q1}.
=======
	itself) \cite[S. 515]{q1}.
\end{quotation}
Das bedeutet, dass der Algorithmus möglichst schmale Bäume zeichnen soll. Jedoch wird die Höhe des Baumes durch diese Anforderungen
nicht eingeschränkt. Stattdessen ist die Höhe durch den Baum vorgegeben \cite[S. 515]{q1}.
>>>>>>> 47125e292bfcfdb0677f356a55bd4002e82bc2b5

Die Naivität des Algorithmus besteht in seiner Simplizität. Dieser Algorithmus soll nur die beiden oberen Anforderungen erfüllen,
während die anderen Algorithmen, neben den beiden oberen, noch weitere Anforderungen erfüllen müssen.  

\label{chap:kapitel3_1_Ablauf}
\subsection{Ablauf}
Ziel dieses Algorithmus ist es, jedem Knoten eine genaue X- und Y-Koordinate in Abhängigkeit ihrer Beziehung zu ihrem Vor- und Nachgängern
zuzuordnen. Dafür muss eine Datenstruktur definiert werden, welche dies ermöglicht. Jeder Knoten muss sowohl seinen Vater als auch eventuelle
Kinder kennen. Zudem muss jeder Knoten in der Lage sein, seine X-Koordinate sowie seine Höhe und Y-Koordinate zu speichern. Da jeder Knoten
nun seine Beziehungen kennt, kann über dem Baum traversiert werden. Zudem kann jeder Knoten nun so seine Koordinaten speichern.

Dieser Algorithmus besitzt zwei Eingabeparameter: Die Wurzel und die Höhe des Baumes.
Die Wurzel muss hierbei vom Typ der zuvor definierten Struktur sein. Zu Beginn wird eine Variable definiert:
Ein Array (später Positions-Array genannt), welches die jeweils nächste freie X-Position einer Ebene des Baums beinhaltet.
Hiernach wird über die Baumstruktur der Wurzel, in der Pre-Order-Traversierung, traversiert.
Nun werden die X- und Y-Attribute der Knoten wie folgt bestimmt und gesetzt:

Der derzeitige Knoten bekommt als X-Position den Wert aus dem Positions-Array, in Abhängigkeit von seiner Höhe im Baum.
Danach wird die Zahl im Positions-Array inkrementiert. Die Y-Position des Knoten wird nun in Abhängigkeit zur Höhe des Knoten
mit der folgenden Formel berechnet: $$y := 2 * HoeheDesKnotens + 1$$

Dieses Vorgehen wird nun für alle Knoten in dem Baum wiederholt. 

Nach dem Durchlaufen aller Knoten des Baumes sind alle X- und Y-Koordinaten gesetzt und der Baum kann gezeichnet werden.
Hierbei bekommen die Knoten eine feste vordefinierte Größe. Die Kanten werden dann als Linien zwischen Vätern und Kindern 
gezeichnet.

\subsection{Implementierung in Java}
Dieser Algorithmus wurde in Java implemeniert. Hierzu wurde die zuvor vorgestellte Datenstruktur
implementiert. Zusätzlich wurden Methoden hinzugefügt, die beispielsweise
ein einfaches Traversieren über den Baum ermöglichen oder zum Setzen von Kindern.

Diese Klasse sieht wie folgt aus:

\begin{lstlisting}[caption=Vereinfachte Implementierung der Knotenklasse, label=code:knotenclass]
class Knoten {
	private Knoten father;
	private Knoten[] childs;
	private int hoehe;
	private int x, y;
	private char data;

	public void traversPreOrder(Consumer<Knoten> cons) { /*...*/ }

	public void setChilds(Knoten... childs) { /*...*/ }

	// Getter, Setter, weitere Hilfsmethoden...
}
\end{lstlisting}
Am Quellcode \ref{code:knotenclass} erkennt man die im vorherigen Kapitel beschriebene Datenstruktur. Die Klasse Knoten beinhaltet genau einen
Vater, ein Array von Kindern, da jeder Knoten mehr als ein Kind haben kann, sowie die Höhe und die Koordinaten. Zusätzlich beinhaltet diese 
Klasse auch noch die Möglichkeit jedem Knoten Daten mitzugeben. Für das Verständnis des Algorithmus ist dies aber nicht notwendig und wird
im Folgenden nicht mehr berücksichtigt. Nachdem diese Klasse erstellt wurde, kann der Algorithmus als Prozedur implementiert werden.
Hierzu wurde eine Prozedur namens \glqq algorithmus1\grqq{} erstellt, die zwei Parameter besitzt: Der Wurzel-Knoten
und die Höhe des Baums. Die weitere Implementierung wird, wie zuvor beschrieben, durchgeführt. Eine mögliche Implementierung
kann wie folgt aussehen:

\begin{lstlisting}[caption=Implementierung des naiven Algorithmus, label=code:naiverAlgo]
public static void algorithmus1(Knoten wurzel, int maximaleHoehe) 
{
	int[] nextX = new int[maximaleHoehe];
	for(int i = 0; i < nextX.length; i++)
		nextX[i] = 1;
	
	wurzel.traversPreOrder(knoten -> {
		knoten.setX(nextX[knoten.getHoehe()]);
		knoten.setY(2 * knoten.getHoehe() + 1);
		
		nextX[knoten.getHoehe()] += 1;
	});
}
\end{lstlisting}
An \ref{code:naiverAlgo} erkennt man, wie die Koordinaten gesetzt werden. Ein Integer-Array wird mit Einsen gefüllt. Danach wird über den Baum
traversiert. Dabei wird bei jedem besuchten Knoten die Setter Methoden für die beiden Koordinaten aufgerufen. Zum Schluss wird das Array an der 
Höhe des aktuell besuchten Knotens inkrementiert, damit der nächste Knoten auf der selben Höhe um eine Position weiter rechts platziert wird.
Wird diese Prozedur mit einer Baumstruktur aufgerufen, so werden alle X- und Y-Koordinaten gesetzt.
Ein Beispiel für einen gezeichneten Baum kann in der Abbildung \ref{pic:baum_algo_1} betrachet werden.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm, height=10cm]{abbildungen/baum_algo_1}
    \caption{Gezeichneter Baum durch den ersten Algorithmus}
    \label{pic:baum_algo_1} 
\end{figure}

\subsection{Vor- und Nachteile}
Die Abbildung \ref{pic:baum_algo_1} zeigt einen Baum, welcher von unserer Java-Implementierung des naiven Algorithmus von Wetherell und Shannon
gezeichnet wurde.
Auf dem ersten Blick wird deutlich, dass dieser gezeichnete Baum maximal schmal ist, da jeder Knoten so weit links wie möglich steht.
Diese Eigenschaft wird aber nur auf Kosten der Übersichtlichkeit erfüllt. Bei der Beziehung zwischen H als Vater und I und J als Sohn wird 
deutlich, dass der von diesem Algorithmus gezeichnete Baum unübersichtlich ist. Außerdem sagt die Position der Knoten nichts über die Daten 
aus, welche die Knoten beinhalten könnten. Egal ob die Daten, welche I und J beinhalten, größer oder kleiner als die Daten in H wären, 
sie würden trotzdem an der selben Position stehen. 
Deshalb definieren Wetherell und Shannon weitere Anforderungen, die Algorithmen zum Zeichnen von Bäumen erfüllen müssen.

