\chapter{Algorithmen zum Zeichnen von Bäumen}
\label{chap:kapitel3}

\section{Naiver Algorithmus von Wetherell und Shannon}

Das Paper “Tidy Drawings of Trees” von Charles Wetherell und Alfred Shannon aus dem Jahre 1979, 
welches im IEEE Trans. Softw. Eng. erschienen ist, handelt von verschiedenen Algorithmen zum Zeichnen von Bäumen.
Der erste Algorithmus, der von den beiden Autoren beschrieben und vorgestellt wird, ist ein naiver Algorithmus 
zum Zeichnen von Bäumen. Dieser Algorithmus soll dabei zwei Anforderungen erfüllen. Die erste Anforderung wird dabei
an die Ästhetik des gezeichneten Baumes gestellt. 
\begin{quotation}
	\textit{Aesthetic 1:} Nodes of a tree at the same height should lie
	along a straight line, and the straight lines defining the levels
	should be parallel.\cite[]{q1}
\end{quotation}
Alle Knoten, die dieselbe Höhe haben, sollen sich auf einer horizontalen
Linie befinden. Jede Höhe hat dabei eine Linie, auf welcher sich die Knoten befinden sollen und diese Linien sollen alle
parallel zueinander sein. Außerdem soll der Algorithmus beim Zeichnen eines Baumes ein physikalisches Limit einhalten.
\begin{quotation}
	\textit{Physical limit:} Tree drawings should occupy as little width
	as possible (the height of a tree drawing is fixed by the tree
	itself).\cite[]{q1}
\end{quotation}
Das bedeutet, dass der Algorithmus möglichst schmale Bäume zeichnen soll. Jedoch wird die Höhe des Baumes durch diese Anforderungen
nicht eingeschränkt. Stattdessen bestimmt der Baum selbst seine Höhe. \cite[]{q1}


\subsection{Ablauf}
Bevor die Funktionsweise des Algorithmus beschrieben werden kann, muss die Baumstruktur 
wie folgt definiert sein: Sie benötigt eine Struktur die symbolisch für ein Knoten des Baums steht. 
Diese Knoten-Struktur muss hierbei ihren Vater kennen, auf ihre Kinder zugreifen können, ihre Position und
Höhe im Baum speichern können.

Dieser Algorithmus besitzt zwei Eingabeparameter: Die Wurzel und Höhe des Baumes.
Die Wurzel muss hierbei vom Typ der zuvor definierten Struktur sein. Zu Beginn wird eine Variable definiert:
Ein Array (später Positions-Array genannt), die die jeweils nächst freie X-Position einer Ebene des Baums beinhaltet.
Hiernach wird über die Baumstruktur der Wurzel, in der Pre-Order-Traversierung, traversiert.
Nun werden die X und Y Attribute der Knoten wie folgt bestimmt und gesetzt:

Der derzeitige Knoten bekommt als X-Position den Wert aus dem Positions-Array, in Abhängigkeit von seiner Höhe im Baum.
Hiernach wird die Zahl im Positions-Array inkrementiert. Die Y-Position des Knoten wird nun in Abhängigkeit zur Höhe des Knoten
mit der folgenden Formel berechnet: $$y := 2 * HoeheDesKnotens + 1$$

Dieses Vorgehen wird nun für alle Knoten in dem Baum wiederholt. 

Nach dem Durchlaufen aller Knoten des Baumes sind alle X und Y-Koordinate gesetzt und der Baum kann gezeichnet werden.

\subsection{Implementierung in Java}
Dieser Algorithmus wurde in Java implemeniert. Hierzu wurde die zuvor vorgestellte Datenstruktur
implementiert. Zusätzlich wurden Methoden hinzugefügt, die Beispielsweise
ein einfaches traversieren über den Baum ermöglichen oder zum Setzen von Kindern.

Diese Klasse sieht wie folgt aus:

\begin{lstlisting}
static class Knoten {
	Knoten vater;
	Knoten[] kinder;
	int hoehe;
	int x, y;

	public void traversPreOrder(Consumer<Knoten> cons) { /*...*/ }

	public void setChilds(Knoten... childs) { /*...*/ }

	// ...
}
\end{lstlisting}

Nachdem diese Klasse implemeniert wurde, kann der Algorithmus als Prozedur implemeniert werden.
Hierzu wurde eine Prozedur namens 'algorithmus1' erstellt, die zwei Parameter besitzt: Der Wurzel-Knoten
und die Höhe des Baums. Die weitere Implementierung wird wie zuvor beschrieben durchgeführt. Eine mögliche Implementierung
kann wie folgt aussehen:

\begin{lstlisting}
public static void algorithmus1(Knoten root, int maximaleHoehe) {
	int[] nextX = new int[maximaleHoehe];
	for(int i = 0; i < nextX.length; i++)
		nextX[i] = 1;

	root.traversPreOrder(knoten -> {
		knoten.x = nextX[knoten.hoehe];
		knoten.y = 2 * knoten.hoehe + 1;
		
		nextX[knoten.hoehe] += 1;
	});
}
\end{lstlisting}

Wird diese Prozedur mit einer Baumstruktur aufgerufen, so werden alle X und Y-Koordinaten gesetzt.
Ein Beispiel für einen gezeichneten Baum kann in der Abbildung \ref{pic:baum_algo_1} betrachet werden.

\begin{figure}
    \centering
    \includegraphics[width=7cm, height=10cm]{abbildungen/baum_algo_1}
    \caption{Gezeichneter Baum durch den ersten Algorithmus}
    \label{pic:baum_algo_1} 
\end{figure}

\subsection{Vor- und Nachteile}
Die Abbildung \ref{pic:baum_algo_1} zeigt einen Baum, welcher von unserer Java-Implementierung des naiven Algorithmus von Wetherell und Shannon
gezeichnet wurde.
Auf dem ersten Blick wird deutlich, dass dieser gezeichnete Baum maximal schmal ist, da jeder Knoten so weit links wie möglich steht.
Diese Eigenschaft wird aber nur auf Kosten der Übersichtlichkeit erfüllt. Sieht man sich die Beziehung zwischen dem Vater H und seinen Kindern
I und J an, erkennt man, dass dieser Baum unübersichtlich ist. Außerdem sagt die Position der Knoten nichts über die Daten aus, welche die Knoten
beinhalten könnten. Egal ob I und J größer oder kleiner als H wären, sie würden trotzdem an der selben Position stehen. Deshalb definieren
Wetherell und Shannon weitere Anforderungen, die Algorithmen zum Zeichnen von Bäume erfüllen müssen.

\section{Verbesserter Algorithmus von Wetherell und Shannon}
Wetherell und Shannon stellen in ihrem Paper einen weiteren, verbesserten Algorithmus zum Zeichnen von Bäumen vor, welcher jedoch
ausschließlich Binärbäume zeichnen kann. Dieser Algorithmus weist die Nachteile des naiven Algorithmus nicht mehr auf.
Dafür definieren sie zwei weitere Anforderungen, die der Algorithmus erfüllen soll.   

\begin{quotation}
	\textit{Aesthetic 2:} In a binary tree, each left son should be positioned
	left of its father and each right son right of its father.\cite[]{q1}
\end{quotation}

In einem Binärbaum hat jeder Knoten maximal ein linkes und maximal ein rechtes Kind. Daher ist es auch logisch, dass jedes linke Kind 
links vom Vater und jedes rechte Kind rechts vom Vater positioniert werden soll. Die zweite weitere Anforderung 

\subsection{Vor- und Nachteile}

\section{Algorithmus von Reingold und Tilford}

\subsection{Ablauf}

\subsection{Implementierung in Java}

\subsection{Vor- und Nachteile}

\subsection{Modifizierung des Algorithmus}
